# P.386 # 최단 경로 # 플로이드-워셜 # 교재 약간 참고
# Q38. 정확한 순위

# 선생님이 시험을 본 학생 N명의 성적을 분실하고, 성적 비교 결과 일부만 가지고 있다.
# 학생 N명의 성적은 모두 다르고 성적 비교 결과를 통해 유추해서 순위를 정확히 알 수 있는 학생도 있고,
# 알 수 없는 학생도 있다. 학생들의 성적을 비교한 결과가 주어질 때 성적 순위를 정확히 알 수 있는
# 학생은 모두 몇 명인지 계산하는 프로그램을 작성하라.

# 첫째 줄에 학생들의 수 N(2<=N<=500)과 두 학생의 성적을 비교한 횟수 M(2<=M<=10,000)이 주어진다.
# 다음 M개의 각 줄에는 두 학생의 성적을 비교한 결과를 나타내는 두 양의 정수 A와 B가 주어진다.
# 이는 A번의 학생 성적이 B번 학생보다 낮다는 것을 의미한다.

# 방향식 그래프로 연결.
# 어떻게든 모든 노드들과 연결이 되어있다면 순위 파악 가능 ? -> X
# 모든 노드들에 연결되어 있으면서 (1부터 n번 노드까지 모두 확인한 거리 값이 999 이상이면 안됨)
# 플로이드 워셜 알고리즘 : 중간점이 1, 2, 3... 일때 최단 거리 계산.

INF = int(1e9)
n, m = map(int, input().split())
arr = [[INF] * (n+1) for _ in range(n+1)] # 거리를 저장할 배열
# 본인 -> 본인 노드 거리 0으로 초기화
for i in range(1, n+1) :
    for j in range(1, n+1) :
        if i == j :
            arr[i][j] = arr[j][i] = 0

for _ in range(m) :
    a, b = map(int, input().split())
    arr[a][b] = 1 # arr[b][a]도 같이 1로 할지 고민

# 플로이드 워셜
for k in range(1, n+1) :
    for i in range(1, n+1) :
        for j in range(1, n+1) :
            arr[i][j] = min(arr[i][j], arr[i][k] + arr[k][j])

res = 0
for i in range(1, n+1) :
    count = 0
    for j in range(1, n+1) :
        # ⭐️ 가는 것 오는 것을 둘 다 체크하기 위한 방법 ⭐️
        if arr[i][j] != INF or arr[j][i] != INF :
            count+=1
    if count == n :
        res += 1

print(res)
